#!/usr/bin/env bash

UNAMEOUT="$(uname -s)"
case "${UNAMEOUT}" in
    Linux*)     MACHINE=linux;;
    Darwin*)    MACHINE=mac;;
    *)          MACHINE="UNKNOWN"
esac

if [ "$MACHINE" == "UNKNOWN" ]; then
    echo "Unsupported system type"
    echo "System must be a Macintosh or Linux"
    echo ""
    echo "System detection determined via uname command"
    echo "If the following is empty, could not find uname command: $(which uname)"
    echo "Your reported uname is: $(uname -s)"
fi

# Set environment variables for dev
if [ "$MACHINE" == "linux" ]; then
    export XDEBUG_HOST=$(/sbin/ifconfig docker0 | grep "inet addr" | cut -d ':' -f 2 | cut -d ' ' -f 1)
    SEDCMD="sed -i"
elif [ "$MACHINE" == "mac" ]; then
    export XDEBUG_HOST=$(ipconfig getifaddr en0) # Ethernet

    if [ -z "$XDEBUG_HOST" ]; then
        export XDEBUG_HOST=$(ipconfig getifaddr en1) # Wifi
    fi

    SEDCMD="sed -i .bak"
fi

export DOCKER_APP_PORT=${DOCKER_APP_PORT:-80}
export DOCKER_PGSQL_PORT=${DOCKER_PGSQL_PORT:-5432}
export DB_DATABASE=${DB_DATABASE:-homestead}
export DB_USERNAME=${DB_USERNAME:-homestead}
export DB_PASSWORD=${DB_PASSWORD:-secret}
export DOCKER_PGSQL_TEST_PORT=${DOCKER_PGSQL_TEST_PORT:-5433}
export DOCKER_PGSQL_TEST_DIR=${DOCKER_PGSQL_TEST_DIR:-./docker/testing/db}
export PGPASSWORD=${DB_PASSWORD}

# Is the environment running
PSRESULT="$(docker-compose ps -q)"
if [ ! -z "$PSRESULT" ]; then
    EXEC="yes"
else
    EXEC="no"
fi

# Create base docker-compose command to run
COMPOSE="docker-compose -f docker-compose.yml"
DOCKER_PHP="docker run --rm -it -v $(pwd):/var/www/html brackets/php7.1"

# If we pass any arguments...
if [ $# -gt 0 ]; then

    # Source .env, which can over-ride env vars
    if [ -f .env ]; then
        source .env
    fi

    if [ "$1" == "craftable" ]; then
        echo "This command will install new craftable application to current folder"

        # caftable new
        # use php container to create craftable new without install
        $DOCKER_PHP craftable new --no-install ./application

        # move application content to this folder
        mv application/* application/.* .
        rm -rf ./application

        # .env modify values
        if [ -f .env ]; then
            source .env
            cp .env .env.bckp

            echo -e "#docker-config\n" >> .env.example
            echo -e "DOCKER_APP_PORT=8080\n" >> .env.example
            echo -e "DOCKER_PGSQL_PORT=5432\n" >> .env.example
            echo -e "DOCKER_PGSQL_TEST_DIR=./docker/testing/db\n" >> .env.example

            echo -e "" >> .env
            echo -e "#docker-config" >> .env
            echo -e "DOCKER_APP_PORT=8080" >> .env
            echo -e "DOCKER_PGSQL_PORT=5432" >> .env
            echo -e "DOCKER_PGSQL_TEST_DIR=./docker/testing/db" >> .env

            source .env

            $SEDCMD "s/APP_URL=.*/APP_URL=http:\/\/localhost:"$DOCKER_APP_PORT"/" .env
            $SEDCMD "s/DB_CONNECTION=.*/DB_CONNECTION=pgsql/" .env
            $SEDCMD "s/DB_HOST=.*/DB_HOST=pgsql/" .env
            $SEDCMD "s/DB_PORT=.*/DB_PORT=5432/" .env
            $SEDCMD "s/DB_DATABASE=.*/DB_DATABASE=homestead/" .env
            $SEDCMD "s/DB_USERNAME=.*/DB_USERNAME=homestead/" .env
            $SEDCMD "s/DB_PASSWORD=.*/DB_PASSWORD=secret/" .env
            $SEDCMD "s/CACHE_DRIVER=.*/CACHE_DRIVER=redis/" .env
            $SEDCMD "s/SESSION_DRIVER=.*/SESSION_DRIVER=redis/" .env
            $SEDCMD "s/REDIS_HOST=.*/REDIS_HOST=redis/" .env

            # removed bak file
            if [ -f .env.bak ]; then
                rm .env.bak
            fi
        fi

        # add predis as required package
        $DOCKER_PHP composer require predis/predis

        # creating dir for testing database
        if [ ! -d ${DOCKER_PGSQL_TEST_DIR} ]; then
            mkdir -p ${DOCKER_PGSQL_TEST_DIR}
        fi

        # source actual env values
        source .env

        # start docker containers
        $COMPOSE up -d

        # making harbor command available
        chmod +x harbor

        # install craftable
        ./harbor art craftable:install

        # npm install
        ./harbor npm install

        # npm run dev
        ./harbor npm run dev

    # Start up containers
    elif [ "$1" == "init" ]; then
        echo "This command will setup your docker environment for this laravel based project"

        if [ ! -f .env.example ]; then
            echo "No .env.example file found within current working directory $(pwd), this is not a laravel project, so please run harbor install"
            exit 0
        fi

        # cp .env.example .env - modify values
        if [ ! -f .env ] && [ -f .env.example ]; then
            cp .env.example .env
        fi
        if [ -f .env ]; then
            source .env
            cp .env .env.bckp

            $SEDCMD "s/APP_URL=.*/APP_URL=http:\/\/localhost:"$DOCKER_APP_PORT"/" .env
            $SEDCMD "s/DB_CONNECTION=.*/DB_CONNECTION=pgsql/" .env
            $SEDCMD "s/DB_HOST=.*/DB_HOST=pgsql/" .env
            $SEDCMD "s/CACHE_DRIVER=.*/CACHE_DRIVER=redis/" .env
            $SEDCMD "s/SESSION_DRIVER=.*/SESSION_DRIVER=redis/" .env
            $SEDCMD "s/REDIS_HOST=.*/REDIS_HOST=redis/" .env

            # removed bak file
            if [ -f .env.bak ]; then
                rm .env.bak
            fi
        fi

        # composer require predis and install - in a composer container
        $DOCKER_PHP composer require predis/predis

        # vs art key:generate
        source .env
        if [[ -z "${APP_KEY}" ]]; then
            $DOCKER_PHP php artisan key:generate
        fi

        # creating dir for testing database
        if [ ! -d ${DOCKER_PGSQL_TEST_DIR} ]; then
            mkdir -p ${DOCKER_PGSQL_TEST_DIR}
        fi

        # source actual env values
        source .env

        # start docker containers
        $COMPOSE up -d

        # making harbor command available
        chmod +x harbor

        # migrate and seed
        ./harbor art migrate --seed

        # npm install
        ./harbor npm install

        # npm run dev
        ./harbor npm run dev

    # Start up containers
    elif [ "$1" == "start" ]; then
        $COMPOSE up -d

    # Stop the containers
    elif [ "$1" == "stop" ]; then
        $COMPOSE down

    # If "artisan" or "art" is used, pass to "artisan" inside a new container
    elif [ "$1" == "artisan" ] || [ "$1" == "art" ]; then
        shift 1
        if [ "$EXEC" == "yes" ]; then
            $COMPOSE exec \
                php \
                php artisan "$@"
        else
            $COMPOSE run --rm \
                php \
                php artisan "$@"
        fi

    # If "composer" or "comp" is used, pass to "composer" inside a new container
    elif [ "$1" == "composer" ] || [ "$1" == "comp" ]; then
        shift 1
        if [ "$EXEC" == "yes" ]; then
            $COMPOSE exec \
                php \
                composer "$@"
        else
            $COMPOSE run --rm \
                php \
                composer "$@"
        fi

    # If "test" is used, run unit tests, pass any extra arguments to phpunit
    elif [ "$1" == "test" ]; then
        shift 1
        export APP_ENV="testing"
        $COMPOSE run --rm \
            php \
            ./vendor/bin/phpunit "$@"

    # If "npm" is used, run npm from our node container
    elif [ "$1" == "npm" ]; then
        shift 1
        $COMPOSE run --rm \
            node \
            npm "$@"

    # If "yarn" is used, run yarn from our node container
    elif [ "$1" == "yarn" ]; then
        shift 1
        $COMPOSE run --rm \
            node \
            yarn "$@"

    # If "gulp" is used, run gulp from our node container
    elif [ "$1" == "gulp" ]; then
        shift 1
        $COMPOSE run --rm \
            node \
            ./node_modules/.bin/gulp "$@"

    # If "psql" is used, run psql from our existing pgsql container
    elif [ "$1" == "psql" ]; then
        shift 1
        if [ "$EXEC" == "yes" ]; then
            $COMPOSE exec \
                pgsql \
                psql -U $DB_USERNAME -h localhost $DB_DATABASE "$@"
        fi

    # If "pg_dump" is used, run pg_dump from our existing pgsql container
    elif [ "$1" == "pg_dump" ]; then
        shift 1
        if [ "$EXEC" == "yes" ]; then
            $COMPOSE exec \
                pgsql \
                pg_dump -U $DB_USERNAME -h localhost $DB_DATABASE "$@"
        fi

    # Else, pass args to docker-compose
    else
        $COMPOSE "$@"
    fi
else
    # Use the docker-compose ps command if nothing else passed through
    $COMPOSE ps
fi
