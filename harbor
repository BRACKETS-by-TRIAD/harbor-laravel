#!/usr/bin/env bash

UNAMEOUT="$(uname -s)"
case "${UNAMEOUT}" in
    Linux*)     MACHINE=linux;;
    Darwin*)    MACHINE=mac;;
    *)          MACHINE="UNKNOWN"
esac

if [ "$MACHINE" == "UNKNOWN" ]; then
    echo "Unsupported system type"
    echo "System must be a Macintosh or Linux"
    echo ""
    echo "System detection determined via uname command"
    echo "If the following is empty, could not find uname command: $(which uname)"
    echo "Your reported uname is: $(uname -s)"
fi

# Set environment variables for dev
if [ "$MACHINE" == "linux" ]; then
    export XDEBUG_HOST=$(/sbin/ifconfig docker0 | grep "inet addr" | cut -d ':' -f 2 | cut -d ' ' -f 1)
    SEDCMD="sed -i"
elif [ "$MACHINE" == "mac" ]; then
    export XDEBUG_HOST=$(ipconfig getifaddr en0) # Ethernet

    if [ -z "$XDEBUG_HOST" ]; then
        export XDEBUG_HOST=$(ipconfig getifaddr en1) # Wifi
    fi

    SEDCMD="sed -i .bak"
fi

# making harbor command available
chmod +x ./harbor

export DOCKER_APP_PORT=${DOCKER_APP_PORT:-80}
export DOCKER_PGSQL_PORT=${DOCKER_PGSQL_PORT:-5432}
export DOCKER_PGSQL_TEST_PORT=${DOCKER_PGSQL_TEST_PORT:-5433}
export DOCKER_PGSQL_TEST_DIR=${DOCKER_PGSQL_TEST_DIR:-./docker/testing/db}

export DB_DATABASE=${DB_DATABASE:-homestead}
export DB_USERNAME=${DB_USERNAME:-homestead}
export DB_PASSWORD=${DB_PASSWORD:-secret}
export PGPASSWORD=${DB_PASSWORD}

# Is the environment running
PSRESULT="$(docker-compose ps -q)"
if [ ! -z "$PSRESULT" ]; then
    EXEC="yes"
else
    EXEC="no"
fi

# Create base docker-compose command to run
COMPOSE="docker-compose -f docker-compose.yml"
DOCKER_PHP="docker run --rm -it -v $(pwd):/var/www/html brackets/php7.1"

# If we pass any arguments...
if [ $# -gt 0 ]; then

    # Source .env, which can over-ride env vars
    if [ -f .env ]; then
        source .env
    fi

    # Start up containers
    if [ "$1" == "start" ]; then
        # creating dir for testing database if not exists already
        if [ ! -d ${DOCKER_PGSQL_TEST_DIR} ]; then
            mkdir -p ${DOCKER_PGSQL_TEST_DIR}
        fi
        $COMPOSE up -d

    # Stop the containers
    elif [ "$1" == "stop" ]; then
        $COMPOSE down

    # Restart the containers
    elif [ "$1" == "restart" ]; then
        if [ "$EXEC" == "yes" ]; then
            ./harbor stop
        fi
        ./harbor start

    # Rebuild the containers
    elif [ "$1" == "rebuild" ]; then
        if [ "$EXEC" == "yes" ]; then
            $COMPOSE down -v
            rm -rf ${DOCKER_PGSQL_TEST_DIR}/*
        fi
        $COMPOSE build
        ./harbor start

    # If "artisan" or "art" is used, pass to "artisan" inside a container
    elif [ "$1" == "artisan" ] || [ "$1" == "art" ]; then
        shift 1
        if [ "$EXEC" == "yes" ]; then
            $COMPOSE exec \
                php \
                php artisan "$@"
        else
            $COMPOSE run --rm \
                php \
                php artisan "$@"
        fi

    # If "composer" or "comp" is used, pass to "composer" inside a container
    elif [ "$1" == "composer" ] || [ "$1" == "comp" ]; then
        shift 1
        if [ "$EXEC" == "yes" ]; then
            $COMPOSE exec \
                php \
                composer "$@"
        else
            $COMPOSE run --rm \
                php \
                composer "$@"
        fi

    # If "test" is used, run unit tests, pass any extra arguments to phpunit
    elif [ "$1" == "test" ]; then
        shift 1
        export APP_ENV="testing"
        $COMPOSE run --rm \
            php \
            ./vendor/bin/phpunit "$@"

    # If "npm" is used, run npm from our node container
    elif [ "$1" == "npm" ]; then
        shift 1
        $COMPOSE run --rm \
            node \
            npm "$@"

    # If "yarn" is used, run yarn from our node container
    elif [ "$1" == "yarn" ]; then
        shift 1
        $COMPOSE run --rm \
            node \
            yarn "$@"

    # If "gulp" is used, run gulp from our node container
    elif [ "$1" == "gulp" ]; then
        shift 1
        $COMPOSE run --rm \
            node \
            ./node_modules/.bin/gulp "$@"

    # If "psql" is used, run psql from our existing pgsql container
    elif [ "$1" == "psql" ]; then
        shift 1
        if [ "$EXEC" == "yes" ]; then
            $COMPOSE exec \
                pgsql \
                psql -U $DB_USERNAME -h localhost $DB_DATABASE "$@"
        fi

    # If "pg_dump" is used, run pg_dump from our existing pgsql container
    elif [ "$1" == "pg_dump" ]; then
        shift 1
        if [ "$EXEC" == "yes" ]; then
            $COMPOSE exec \
                pgsql \
                pg_dump -U $DB_USERNAME -h localhost $DB_DATABASE "$@"
        fi

    # Installing laravel or initialize laravel project for harbor
    elif [ "$1" == "laravel" ]; then
        if [ "$2" == "new" ]; then
            echo "This command will install new laravel application to current folder"

            # laravel new
            # use php container to create craftable new without install
            $DOCKER_PHP laravel new ./application

            # move application content to this folder
            mv application/* application/.* .
            rm -rf ./application

            ./harbor init

        elif [ "$2" == "init" ]; then
            ./harbor init
        fi

    # Installing craftable or initialize craftable project for harbor
    elif [ "$1" == "craftable" ]; then
        if [ "$2" == "new" ]; then
            echo "This command will install new craftable application to current folder"

            # caftable new
            # use php container to create craftable new without install
            $DOCKER_PHP craftable new --no-install ./application

            # move application content to this folder
            mv application/* application/.* .
            rm -rf ./application

            # .env modify values
            if [ -f .env ]; then
                source .env

                # make backup of .env and add it to .gitignore file
                cp .env .env.bckp
                if [ -f .gitignore ] && [grep -q ".env.bckp" "./.gitignore"]; then
                    echo -e ".env.bckp\n" >> .gitignore
                fi

                if [grep -q "#docker-config" ".env.example"]; then
                    $SEDCMD "s/DOCKER_APP_PORT=.*/DOCKER_APP_PORT="$DOCKER_APP_PORT"/" .env.example
                    $SEDCMD "s/DOCKER_PGSQL_PORT=.*/DOCKER_PGSQL_PORT="$DOCKER_PGSQL_PORT"/" .env.example
                    $SEDCMD "s/DOCKER_PGSQL_TEST_PORT=.*/DOCKER_PGSQL_TEST_PORT="$DOCKER_PGSQL_TEST_PORT"/" .env.example
                    $SEDCMD "s/DOCKER_PGSQL_TEST_DIR=.*/DOCKER_PGSQL_TEST_DIR="$DOCKER_PGSQL_TEST_DIR"/" .env.example
                else
                    echo -e "#docker-config\n" >> .env.example
                    echo -e "DOCKER_APP_PORT="$DOCKER_APP_PORT"\n" >> .env.example
                    echo -e "DOCKER_PGSQL_PORT="$DOCKER_PGSQL_PORT"\n" >> .env.example
                    echo -e "DOCKER_PGSQL_TEST_PORT="$DOCKER_PGSQL_TEST_PORT"\n" >> .env.example
                    echo -e "DOCKER_PGSQL_TEST_DIR=."$DOCKER_PGSQL_TEST_DIR"\n" >> .env.example
                fi

                if [grep -q "#docker-config" ".env"]; then
                    $SEDCMD "s/DOCKER_APP_PORT=.*/DOCKER_APP_PORT="$DOCKER_APP_PORT"/" .env
                    $SEDCMD "s/DOCKER_PGSQL_PORT=.*/DOCKER_PGSQL_PORT="$DOCKER_PGSQL_PORT"/" .env
                    $SEDCMD "s/DOCKER_PGSQL_TEST_PORT=.*/DOCKER_PGSQL_TEST_PORT="$DOCKER_PGSQL_TEST_PORT"/" .env
                    $SEDCMD "s/DOCKER_PGSQL_TEST_DIR=.*/DOCKER_PGSQL_TEST_DIR="$DOCKER_PGSQL_TEST_DIR"/" .env
                else
                    echo -e "#docker-config\n" >> .env
                    echo -e "DOCKER_APP_PORT="$DOCKER_APP_PORT"\n" >> .env
                    echo -e "DOCKER_PGSQL_PORT="$DOCKER_PGSQL_PORT"\n" >> .env
                    echo -e "DOCKER_PGSQL_TEST_PORT="$DOCKER_PGSQL_TEST_PORT"\n" >> .env
                    echo -e "DOCKER_PGSQL_TEST_DIR=."$DOCKER_PGSQL_TEST_DIR"\n" >> .env
                fi

                source .env

                $SEDCMD "s/DB_DATABASE=.*/DB_DATABASE=homestead/" .env
                $SEDCMD "s/DB_USERNAME=.*/DB_USERNAME=homestead/" .env
                $SEDCMD "s/DB_PASSWORD=.*/DB_PASSWORD=secret/" .env

                $SEDCMD "s/APP_URL=.*/APP_URL=http:\/\/localhost:"$DOCKER_APP_PORT"/" .env

                $SEDCMD "s/DB_CONNECTION=.*/DB_CONNECTION=pgsql/" .env
                $SEDCMD "s/DB_HOST=.*/DB_HOST=pgsql/" .env
                $SEDCMD "s/DB_PORT=.*/DB_PORT=5432/" .env

                $SEDCMD "s/CACHE_DRIVER=.*/CACHE_DRIVER=redis/" .env
                $SEDCMD "s/SESSION_DRIVER=.*/SESSION_DRIVER=redis/" .env
                $SEDCMD "s/REDIS_HOST=.*/REDIS_HOST=redis/" .env

                # removed bak file
                if [ -f .env.bak ]; then
                    rm .env.bak
                fi
            fi

            # add predis as required package
            $DOCKER_PHP composer require predis/predis
            $DOCKER_PHP composer install

            # source actual env values
            source .env

            # restart docker containers
            ./harbor restart

            # install craftable
            ./harbor art craftable:install

            # npm install
            ./harbor npm install

            # npm run dev
            ./harbor npm run dev

        elif [ "$2" == "init" ]; then
            ./harbor init
        fi

    # Initialize harbor for existing project
    elif [ "$1" == "init" ]; then
        echo "This command will setup your docker environment for this laravel based project"

        if [ ! -f .env.example ]; then
            echo "No .env.example file found within current working directory $(pwd), this is not a laravel project, so please run harbor install"
            exit 0
        fi

        # cp .env.example .env if .env is missing
        if [ ! -f .env ] && [ -f .env.example ]; then
            cp .env.example .env
        fi

        # change values in .env file
        if [ -f .env ]; then
            source .env

            # make backup of .env and add it to .gitignore file
            cp .env .env.bckp
            if [ -f .gitignore ] && [grep -q ".env.bckp" "./.gitignore"]; then
                echo -e ".env.bckp\n" >> .gitignore
            fi

            $SEDCMD "s/APP_URL=.*/APP_URL=http:\/\/localhost:"$DOCKER_APP_PORT"/" .env

            $SEDCMD "s/DB_CONNECTION=.*/DB_CONNECTION=pgsql/" .env
            $SEDCMD "s/DB_HOST=.*/DB_HOST=pgsql/" .env
            $SEDCMD "s/DB_PORT=.*/DB_PORT=5432/" .env

            $SEDCMD "s/CACHE_DRIVER=.*/CACHE_DRIVER=redis/" .env
            $SEDCMD "s/SESSION_DRIVER=.*/SESSION_DRIVER=redis/" .env
            $SEDCMD "s/REDIS_HOST=.*/REDIS_HOST=redis/" .env

            # removed bak file
            if [ -f .env.bak ]; then
                rm .env.bak
            fi
        fi

        # composer require predis and install - in a composer container
        $DOCKER_PHP composer require predis/predis
        $DOCKER_PHP composer install

        # vs art key:generate
        source .env
        if [[ -z "${APP_KEY}" ]]; then
            $DOCKER_PHP php artisan key:generate
        fi

        # source actual env values
        source .env

        # restart docker containers
        ./harbor restart

        # migrate and seed
        ./harbor art migrate --seed

        # npm install
        ./harbor npm install

        # npm run dev
        ./harbor npm run dev

    # Else, pass args to docker-compose
    else
        $COMPOSE "$@"
    fi
else
    # Use the docker-compose ps command if nothing else passed through
    $COMPOSE ps
fi
